

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>orb.utils package &mdash; Orb 3.4 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="orb.ext package" href="orb.ext.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Orb
          

          
            
            <img src="_static/logo_sidebar.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">ORB installation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="orb.html">orb package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="orb.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="orb.ext.html">orb.ext package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">orb.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.astrometry">orb.utils.astrometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.err">orb.utils.err module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.fft">orb.utils.fft module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.filters">orb.utils.filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.fit">orb.utils.fit module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.image">orb.utils.image module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.io">orb.utils.io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.log">orb.utils.log module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.misc">orb.utils.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.parallel">orb.utils.parallel module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.photometry">orb.utils.photometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.sim">orb.utils.sim module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.spectrum">orb.utils.spectrum module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.stats">orb.utils.stats module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.validate">orb.utils.validate module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.vector">orb.utils.vector module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.web">orb.utils.web module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#orb-astrometry-module">orb.astrometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.cgvar">orb.cgvar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.constants">orb.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.core">orb.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.cutils">orb.cutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.etc">orb.etc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.fit">orb.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb">Module contents</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Orb</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="orb.html">orb package</a> &raquo;</li>
        
      <li>orb.utils package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/orb.utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="orb-utils-package">
<h1>orb.utils package<a class="headerlink" href="#orb-utils-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-orb.utils.astrometry">
<span id="orb-utils-astrometry-module"></span><h2>orb.utils.astrometry module<a class="headerlink" href="#module-orb.utils.astrometry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="orb.utils.astrometry.Gaussian">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the gaussian profile</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Gaussian profile used here is:
<img src="_images/mathmpl/math-793c1eaca4.png" style="position: relative; bottom: -13px"/></p>
<p>and,
<img src="_images/mathmpl/math-b315917b45.png" style="position: relative; bottom: -8px"/></p>
<p class="last">The total flux F under the 2D profile is:
<img src="_images/mathmpl/math-92a4ae8147.png" style="position: relative; bottom: -3px"/></p>
</div>
<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
<p>The total flux F under a 2D profile is :
<img src="_images/mathmpl/math-92a4ae8147.png" style="position: relative; bottom: -3px"/></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Under a 1d profile the flux is <img src="_images/mathmpl/math-dfa1d83f67.png" style="position: relative; bottom: -3px"/></p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>amplitude_err</strong> – estimation of the amplitude error</li>
<li><strong>width_err</strong> – estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm']</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.width">
<code class="descname">width</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.Moffat">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Moffat</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the Moffat profile.</p>
<p>This profile is useful to fit stars on CCD arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Moffat profile has been first proposed by Moffat
(1969) A&amp;A. The exact form of the equation used has been derived
from Trujillo et al. (2001) MNRAS, 977. The PSF:</p>
<p><img src="_images/mathmpl/math-53e27389e3.png" style="position: relative; bottom: -8px"/></p>
<p>with,
<img src="_images/mathmpl/math-59ca1de64d.png" /></p>
<p>and,
<img src="_images/mathmpl/math-b315917b45.png" style="position: relative; bottom: -8px"/></p>
<p class="last">The total flux F under the 2D profile is thus:
<img src="_images/mathmpl/math-f26f1f47a4.png" style="position: relative; bottom: -14px"/></p>
</div>
<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.alpha">
<code class="descname">alpha</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>amplitude_err</strong> – estimation of the amplitude error</li>
<li><strong>width_err</strong> – estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Not implemented yet!</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm', 'beta']</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.PSF">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">PSF</code><a class="headerlink" href="#orb.utils.astrometry.PSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>General class of inheritance for point spread functions (PSFs)</p>
<dl class="method">
<dt id="orb.utils.astrometry.PSF.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.PSF.params">
<code class="descname">params</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.PSF.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.PSF.varray2d">
<code class="descname">varray2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.varray2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vectorized 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">aperture_photometry</code><span class="sig-paren">(</span><em>star_box</em>, <em>fwhm_guess</em>, <em>background_guess=None</em>, <em>background_guess_err=0.0</em>, <em>aper_coeff=3.0</em>, <em>warn=True</em>, <em>x_guess=None</em>, <em>y_guess=None</em>, <em>return_surfaces=False</em>, <em>aperture_surface=None</em>, <em>annulus_surface=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the aperture photometry of a star centered in a star box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>star_box</strong> – Star box</li>
<li><strong>fwhm_guess</strong> – Guessed FWHM. Used to get the aperture radius.</li>
<li><strong>background_guess</strong> – (Optional) If not None, this guess is
used instead of the background determination in an annulus
around the star (default None).</li>
<li><strong>background_guess_err</strong> – (Optional) Error on the background
guess. Used to compute the aperture photometry error (default 0.).</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for Moffat stars with a high SNR).</li>
<li><strong>warn</strong> – (Optional) If True, print a warning when the background cannot
be well estimated (default True).</li>
<li><strong>x_guess</strong> – (Optional) position of the star along x axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><strong>y_guess</strong> – (Optional) position of the star along y axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><strong>return_surfaces</strong> – (Optional) If True returns also the
aperture_surface and annulus_surface computed. Useful if
multiple stars with the same FWHM must be done (default False).</li>
<li><strong>aperture_surface</strong> – (Optional) Pre-computed
aperture_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if aperture_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
<li><strong>annulus_surface</strong> – (Optional) Pre-computed
annulus_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if annulus_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Tuple (flux, flux_error, aperture surface,
bad_estimation_flag). If the estimation is bad,
bad_estimation_flat is set to 1, else it is set to 0.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best aperture for maximum S/N: 1. FWHM (Howell 1989,
Howell 1992). But that works only when the PSF is well sampled
which is not always the case so a higher aperture coefficient
may be better. More over, to get exact photometry the result
must be corrected by aperture growth curve for the ‘missing
light’. A coefficient of 1.27 FWHM corresponds to 3 sigma and
collects more than 99% of the light if the star is a pure
Gaussian. A coefficient of 3 for Moffat stars reduces the
variations of the proportion of collected photons when the FWHM
is changing and seems to be the best.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best radius for sky background annulus is determined
from this rule of thumb: The number of pixels to estimate the
background must be al least 3 times the number of pixel in the
aperture (Merline &amp; Howell 1995). Choosing the aperture radius
coefficient(Cap) as Rap = Cap * FWHM and the inner radius
coefficient (Cin) as Rin = Cin * FWHM, gives the outer radius
coefficient (Cout): Cout = sqrt(3*Cap^2 + Cin^2)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The star MUST be at the center (+/- 1 pixel) of the
star box.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.brute_force_guess">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">brute_force_guess</code><span class="sig-paren">(</span><em>image</em>, <em>star_list</em>, <em>x_range</em>, <em>y_range</em>, <em>r_range</em>, <em>rc</em>, <em>zoom_factor</em>, <em>box_size</em>, <em>verbose=True</em>, <em>init_wcs=None</em>, <em>raise_border_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.brute_force_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a precise alignment guess by brute force.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list</strong> – List of star position. Must be given in pixels
if no wcs is given (wcs set to None). If a wcs is given must be a
list of ra/dec coordinates.</li>
<li><strong>x_range</strong> – range of x values to check</li>
<li><strong>y_range</strong> – range of y values to check</li>
<li><strong>r_range</strong> – range of angle values to check</li>
<li><strong>rc</strong> – rotation center (rc, ry). If a WCS is given the
rotation center is obtained from the wcs itself and must be set to
None.</li>
<li><strong>zoom_factor</strong> – zoom_factor</li>
<li><strong>verbose</strong> – (Optional) If True, print some informations
(default True).</li>
<li><strong>init_wcs</strong> – (Optional) WCS instance (can contain an SIP distortion
model, default None).</li>
<li><strong>raise_border_error</strong> – (Optional) if True raise an exception
if the returned guess is on the border of the brute force grid
(defaut True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.compute_alignment_vectors">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">compute_alignment_vectors</code><span class="sig-paren">(</span><em>fit_results</em>, <em>min_coeff=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.compute_alignment_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>compute alignement vectors from a list of fit results as returned
by fit_stars_in_cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fit_results</strong> – fit results.</li>
<li><strong>min_coeff</strong> – The minimum proportion of stars correctly fitted
to assume a good enough calculated disalignment (default 0.2).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.compute_radec_pm">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">compute_radec_pm</code><span class="sig-paren">(</span><em>ra_deg</em>, <em>dec_deg</em>, <em>pm_ra_mas</em>, <em>pm_dec_mas</em>, <em>yr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.compute_radec_pm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute RA/DEC in degrees with proper motion values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ra_deg</strong> – RA in degrees</li>
<li><strong>dec_deg</strong> – DEC in degrees</li>
<li><strong>pm_ra_mas</strong> – Proper motion along RA axis in mas/yr</li>
<li><strong>pm_dec_mas</strong> – Proper motion along DEC axis in mas/yr</li>
<li><strong>yr</strong> – Number of years</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.create_wcs">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">create_wcs</code><span class="sig-paren">(</span><em>target_x</em>, <em>target_y</em>, <em>deltax</em>, <em>deltay</em>, <em>target_ra</em>, <em>target_dec</em>, <em>rotation</em>, <em>sip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.create_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a WCS with an optional SIP distortion model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wcs</strong> – Original WCS. If None, a 2 axis WCS is created instead.</li>
<li><strong>target_x</strong> – Target X position in pixels</li>
<li><strong>target_y</strong> – Target Y position in pixels</li>
<li><strong>deltax</strong> – Plate scale in arcdeg / pixel along X axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</li>
<li><strong>deltax</strong> – Plate scale in arcdeg / pixel along Y axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</li>
<li><strong>target_ra</strong> – Target RA</li>
<li><strong>target_dec</strong> – Target DEC</li>
<li><strong>rotation</strong> – Rotation angle</li>
<li><strong>sip</strong> – (Optional) astropy.WCS instance containing a valid SIP.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.dec2deg">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">dec2deg</code><span class="sig-paren">(</span><em>dec</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.dec2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in sexagesimal format to degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dec</strong> – DEC in sexagesimal format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.deg2dec">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">deg2dec</code><span class="sig-paren">(</span><em>deg</em>, <em>string=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in degrees to sexagesimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – DEC in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.deg2ra">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">deg2ra</code><span class="sig-paren">(</span><em>deg</em>, <em>string=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2ra" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in degrees to sexagesimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – RA in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.detect_fwhm_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">detect_fwhm_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>fwhm_guess_pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.detect_fwhm_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect stars FWHM in a frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">star positions must be known precisely</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frame</strong> – Frame</li>
<li><strong>star_list</strong> – List of the positions of the stars used to
detect FWHM.</li>
<li><strong>fwhm_guess_pix</strong> – Initial guess on the FWHM of the stars.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(FWHM, FWHM_ERR) in pixels</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.df2list">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">df2list</code><span class="sig-paren">(</span><em>sources</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.df2list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a sources pandas.DataFrame instance to a list of positions</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit2df">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit2df</code><span class="sig-paren">(</span><em>fit</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit2df" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert fit results to a pandas.DataFrame instance</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_sip">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_sip</code><span class="sig-paren">(</span><em>scale</em>, <em>star_list1</em>, <em>star_list2</em>, <em>params=None</em>, <em>init_sip=None</em>, <em>err=None</em>, <em>sip_order=4</em>, <em>crpix=None</em>, <em>crval=None</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>FIT the distortion correction polynomial to match two lists
of stars (the list of stars 2 is distorded to match the list
of stars 1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> – Plate scale of the image in arcseconds (can be a
tuple (scalex, scaley) or a single float)</li>
<li><strong>star_list1</strong> – list of stars 1</li>
<li><strong>star_list2</strong> – list of stars 2</li>
<li><strong>params</strong> – (Optional) Transformation parameter to go from
the list of stars 1 to the list of stars 2. Must be a tuple
[dx, dy, dr, da, db, rcx, rcy, zoom_factor] (default None).</li>
<li><strong>init_sip</strong> – (Optional) Initial SIP (an astropy.wcs.WCS object,
default None)</li>
<li><strong>err</strong> – (Optional) error on the star positions of the star
list 2 (default None).</li>
<li><strong>sip_order</strong> – (Optional) SIP order (default 3).</li>
<li><strong>crpix</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</li>
<li><strong>crval</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_star">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_star</code><span class="sig-paren">(</span><em>star_box</em>, <em>profile_name='gaussian'</em>, <em>fwhm_pix=None</em>, <em>amp=None</em>, <em>beta=3.5</em>, <em>height=None</em>, <em>pos=None</em>, <em>fix_height=False</em>, <em>fix_amp=False</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>fix_pos=False</em>, <em>fit_tol=0.001</em>, <em>check=True</em>, <em>fwhm_min=0.5</em>, <em>check_reject=False</em>, <em>ron=10.0</em>, <em>dcl=0.0</em>, <em>estimate_local_noise=True</em>, <em>precise_guess=False</em>, <em>saturation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a single star</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_box</strong> – The box where the star has to be fitted.</li>
<li><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</li>
<li><strong>amp</strong> – (Optional) Amplitude guess, replace the value of the
automatic estimation (default None).</li>
<li><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><strong>height</strong> – (Optional) Height guess, replace the value of the
automatic estimation (default None).</li>
<li><strong>pos</strong> – (Optional) Position guess as a tuple (x,y), replace
the value of the automatic estimation (default None).</li>
<li><strong>fix_amp</strong> – (Optional) Fix amplitude parameter to its
estimation (default False)</li>
<li><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation (default False)</li>
<li><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</li>
<li><strong>fix_fwhm</strong> – (Optional) Fix FWHM to its estimation (default
False).</li>
<li><strong>fix_pos</strong> – (Optional) Fix position parameters (x,y) at their
estimated value (default False).</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><strong>check</strong> – (Optional) If True, check fit results for oddities
(default True).</li>
<li><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM [in pixel] of the
fitted star (default 0.5)</li>
<li><strong>check_reject</strong> – (Optional) [Debug] If True, print the reason
why a fit is rejected (default False).</li>
<li><strong>ron</strong> – (Optional) Readout noise in ADU/pixel (default
10.). estimate_local_noise must be set to False for this noise
to be taken into account.</li>
<li><strong>dcl</strong> – (Optional) Dark current level in ADU/pixel (default
0.). estimate_local_noise must be set to False for this noise to
be taken into account.</li>
<li><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl are thus not used (default True).</li>
<li><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known (default False).</li>
<li><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_stars_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_stars_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>box_size</em>, <em>profile_name='gaussian'</em>, <em>scale=None</em>, <em>fwhm_pix=None</em>, <em>beta=3.5</em>, <em>fit_tol=0.01</em>, <em>fwhm_min=0.5</em>, <em>fix_height=None</em>, <em>fix_aperture_fwhm_pix=None</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>readout_noise=10.0</em>, <em>dark_current_level=0.0</em>, <em>local_background=True</em>, <em>no_aperture_photometry=False</em>, <em>precise_guess=False</em>, <em>aper_coeff=3.0</em>, <em>blur=False</em>, <em>no_fit=False</em>, <em>estimate_local_noise=True</em>, <em>multi_fit=False</em>, <em>enable_zoom=False</em>, <em>enable_rotation=False</em>, <em>saturation=None</em>, <em>fix_pos=False</em>, <em>nozero=False</em>, <em>silent=True</em>, <em>sip=None</em>, <em>background_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_stars_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in a frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<ul class="last simple">
<li>Individual fit mode [multi_fit=False]: Stars are all fit
independantly.</li>
<li>Multi fit mode [multi_fit=True]: Stars are fitted all together
considering that the position pattern is well known, the same
shift in x and y will be applied. Optionally the pattern can be
rotated and zoomed. The FWHM is also considered to be the
same. This option is far more robust and precise for alignment
purpose.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frame</strong> – The frame containing the stars to fit.</li>
<li><strong>star_list</strong> – A list of star positions as an array of shape
(star_nb, 2)</li>
<li><strong>box_size</strong> – The size of the box created around a star to fit
its parameter.</li>
<li><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</li>
<li><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><strong>scale</strong> – (Optional) Scale of the frame in arcsec/pixel. If
given the fwhm in arcseconds is also computed (keyword:
‘fwhm_arc’) with the fit parameters (default None).</li>
<li><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation. If None, set by default to True in individual fit
mode [multi_fit=False] and False in multi fit mode
[multi_fit=True] (default None).</li>
<li><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</li>
<li><strong>fix_fwhm</strong> – (Optional) Fix FWHM to the given value or the
estimated value (default False).</li>
<li><strong>fix_pos</strong> – (Optional) Fix x,y positions of the stars to the
given value.</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><strong>nozero</strong> – (Optional) If True do not fit any star which box
(the pixels around it) contains a zero. Valid only in individual
fit mode [multi_fit=False] (default False).</li>
<li><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM of the fitted star
(default 0.5)</li>
<li><strong>silent</strong> – (Optional) If True no messages are printed (default
True).</li>
<li><strong>local_background</strong> – (Optional) If True, height is estimated
localy, i.e. around the star. If False, the sky background is
determined in the whole frame. In individual fit mode
[multi_fit=False] height will be the same for all the stars, and
the fix_height option is thus automatically set to True. In
multi fit mode [multi_fit=True] height is considered as a
covarying parameter for all the stars but it won’t be fixed
(default True).</li>
<li><strong>fix_aperture_fwhm_pix</strong> – (Optional) If a positive float. FWHM
used to scale aperture size is not computed from the mean FWHM
in the frame but fixed to the given float (default None).</li>
<li><strong>no_aperture_photometry</strong> – (Optional) If True, aperture
photometry will not be done after profile fitting (default
False).</li>
<li><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known. Valid only in individual fit mode
[multi_fit=False] (default False).</li>
<li><strong>readout_noise</strong> – (Optional) Readout noise in ADU/pixel (can
be computed from bias frames: std(master_bias_frame)) (default
10.)</li>
<li><strong>dark_current_level</strong> – (Optional) Dark current level in
ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for star with a high SNR).</li>
<li><strong>blur</strong> – (Optional) If True, blur frame (low pass filtering)
before fitting stars. It can be used to enhance the quality of
the fitted flux of undersampled data. Note that the error on
star position can be greater on blurred frame. This option must
not be used for alignment purpose (default False).</li>
<li><strong>no_fit</strong> – (Optional) If True, no fit is done. Only the
aperture photometry. Star positions in the star list must thus
be precise (default False).</li>
<li><strong>multi_fit</strong> – (Optional) If True all stars are fitted at the
same time. More robust for alignment purpose. The difference of
position between the stars in the star list must be precisely
known because the overall shift only is estimated (default
False).</li>
<li><strong>enable_zoom</strong> – (Optional) If True, the stars position pattern
can be zoomed to better adjust it to the real frame. Valid only
in multi fit mode [multi_fit=True] (default False).</li>
<li><strong>enable_rotation</strong> – (Optional) If True, the stars position
pattern can be rotated to better adjust it to the real frame
Valid only in multi fit mode [multi_fit=True] (default False).</li>
<li><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. readout_noise and dark_current_level are thus not used
(default True).</li>
<li><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
<li><strong>sip</strong> – (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</li>
<li><strong>background_value</strong> – (Optional) If not None, this background
value is used in the fit functions and will be fixed for fit and
aperture photometry. Note also that in this case
local_background is automatically set to False (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Parameters of a 2D fit of the stars positions.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.load_star_list()</span></code> to load
a predefined list of stars or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.detect_stars()</span></code> to automatically
create it.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.astrometry.fit_star()</span></code> and
<a class="reference internal" href="orb.html#orb.cutils.multi_fit_stars" title="orb.cutils.multi_fit_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.cutils.multi_fit_stars()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_wcs">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_wcs</code><span class="sig-paren">(</span><em>star_list_pix</em>, <em>star_list_deg</em>, <em>wcs</em>, <em>fitsip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_wcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.get_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">get_profile</code><span class="sig-paren">(</span><em>profile_name</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PSF profile class corresponding to the given profile name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<em>profile</em>) – The name of the PSF profile. Must be ‘moffat’
or ‘gaussian’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.get_wcs_parameters">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">get_wcs_parameters</code><span class="sig-paren">(</span><em>wcs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_wcs_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return comprehensive parameters from a simple WCS as created
with orb.utils.astrometry.create_wcs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wcs</strong> – An astropy.wcs.WCS instance created with
orb.utils.astrometry.create_wcs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">target_x, target_y, deltax, deltay, target_ra,
target_dec, rotation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.guess">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">guess</code><span class="sig-paren">(</span><em>star_box</em>, <em>pos=None</em>, <em>height=None</em>, <em>precise_pos=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimation of the star parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>star_box</strong> – Sub-part of an image surrounding a star. The
center of the star must be placed near the center of the
box. The dimensions of the box must be greater than 3 times
the FWHM of the star.</li>
<li><strong>pos</strong> – (Optional) Position guess as a tuple (x,y). Used to
estimate amplitude (default None).</li>
<li><strong>height</strong> – (Optional) Guess of the background level. Used to
estimate amplitude (default None).</li>
<li><strong>precise_pos</strong> – (Optional) If True, position is estimated from
the marginal distribution of the PSF. Return a far better
estimation if and only if the star is well centered in the box,
i.e. if and only if the position of the star is already
known. This can lead to errors when trying to find the star in
the box, in this case precise_pos must be set to False (default
False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[height,amplitude,x,y,width]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.histogram_registration">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">histogram_registration</code><span class="sig-paren">(</span><em>star_list1</em>, <em>star_list2</em>, <em>dimx</em>, <em>dimy</em>, <em>xy_bins</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.histogram_registration" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast histogram registration of an image based on the comparison
of two star lists: one created from the real star position in the
image and the other from, e.g. a catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list1</strong> – first list of stars</li>
<li><strong>star_list2</strong> – second list of stars</li>
<li><strong>dimx</strong> – X dimension of the image in pixels</li>
<li><strong>dimy</strong> – Y dimension of the image inp ixels</li>
<li><strong>xy_bins</strong> – number of bins along X and Y</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This kind of registration is very sensitive to the
angle between each list. It is better to use it on a range of
angles (steps of 0.5 degree) to make sure the best correlation
is found.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.load_star_list">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">load_star_list</code><span class="sig-paren">(</span><em>star_list</em>, <em>remove_nans=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.load_star_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of stars coordinates from an hdffile or a pandas DataFrame or a numpy.ndarray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Star_list:</th><td class="field-body">can be a np.ndarray of shape (n, 2) or a path to a star list</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remove_nans</strong> – If True, Nans are removed from the output star list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.mag">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">mag</code><span class="sig-paren">(</span><em>flux</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.mag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return the instrumental magnitude of a given flux (magnitude 0</dt>
<dd>is set to 1 e-)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flux</strong> – Flux in e-</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.multi_aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">multi_aperture_photometry</code><span class="sig-paren">(</span><em>frame</em>, <em>pos_list</em>, <em>fwhm_guess_pix</em>, <em>aper_coeff=3.0</em>, <em>detect_fwhm=False</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.multi_aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Aperture photometry of multiple sources in a frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame</li>
<li><strong>pos_list</strong> – List of the positions of the sources</li>
<li><strong>fwhm_guess_pix</strong> – Initial guess on the FWHM of the sources.</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient used for
photometry (default 3.).</li>
<li><strong>detect_fwhm</strong> – (Optional) If True FWHM is automatically
computed from a fit on the sources. Sources must be stars or
bright point sources. If most of the sources are stars this
might work well enough (default False).</li>
<li><strong>silent</strong> – (Optional) Silent function if True (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.pix2world">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">pix2world</code><span class="sig-paren">(</span><em>hdr</em>, <em>dimx</em>, <em>dimy</em>, <em>star_list_pix</em>, <em>dxmap</em>, <em>dymap</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.pix2world" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel positions to RA/DEC coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – pyfits.Header instance</li>
<li><strong>dimx</strong> – Image dimension along X</li>
<li><strong>dimy</strong> – Image dimension along Y</li>
<li><strong>star_list_pix</strong> – List of star coordinates in pixels</li>
<li><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</li>
<li><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.ra2deg">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">ra2deg</code><span class="sig-paren">(</span><em>ra</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.ra2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in sexagesimal format to degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ra</strong> – RA in sexagesimal format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.radial_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">radial_profile</code><span class="sig-paren">(</span><em>a</em>, <em>xc</em>, <em>yc</em>, <em>rmax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.radial_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average radial profile on a region of a 2D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A 2D array</li>
<li><strong>xc</strong> – Center of the profile along x axis</li>
<li><strong>yc</strong> – Center of the profile along y axis</li>
<li><strong>rmax</strong> – Radius of the profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(R axis, V axis). A tuple of 2 vectors giving the radius
axis and the corresponding values axis.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.realign_images">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">realign_images</code><span class="sig-paren">(</span><em>_cube</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.realign_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Realign images of a small cube of images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>_cube</strong> – A 3 dimensional np.ndarray.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This procedure is robust but very slow. Do not use it
to realign a large number of images.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.sky_background_level">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">sky_background_level</code><span class="sig-paren">(</span><em>im</em>, <em>smooth_coeff=0.1</em>, <em>return_mode=False</em>, <em>bins=25</em>, <em>return_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sky_background_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the sky background based on the maximum of
the histogram of the pixels distribution in the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image.</li>
<li><strong>smooth_coeff</strong> – (Optional) the smoothing degree, i.e. the
number of smoothing points is defined by smooth_coeff *
size(histogram) (default 0.05). If smooth_coeff &lt;= 0. no
smoothing is applied.</li>
<li><strong>return_mode</strong> – (Optional) If True the returned value is the
mode (an entire value for a distribution of integers). If False,
return the mean of a sigmacut realized around the mode (a
fractional value, generally more precise).</li>
<li><strong>bins</strong> – (Optional) Number of bins for the histogram (default
20).</li>
<li><strong>return_error</strong> – (Optional) If True, the error on the
estimation is returned (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.transform_star_position_A_to_B">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">transform_star_position_A_to_B</code><span class="sig-paren">(</span><em>star_list_A</em>, <em>params</em>, <em>rc</em>, <em>zoom_factor</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the positions in camera
B given the transformation parameters.</p>
<p>Optionally SIP distorsion parameters can be given.</p>
<p>The transformation steps are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dist_pix_camA</span> <span class="o">-&gt;</span> <span class="n">perf_pix_camA</span> <span class="o">-&gt;</span> <span class="n">geometric</span> <span class="n">transformation_A2B</span>
<span class="o">-&gt;</span> <span class="n">perf_pix_camB</span> <span class="o">-&gt;</span> <span class="n">dist_pix_camB</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_A</strong> – List of star coordinates in the cube A.</li>
<li><strong>params</strong> – Transformation parameters [dx, dy, dr, da, db].</li>
<li><strong>rc</strong> – Rotation center coordinates.</li>
<li><strong>zoom_factor</strong> – Zooming factor between the two cameras. Can be
a couple (zx, zy).</li>
<li><strong>sip_A</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame A (default None).</li>
<li><strong>sip_B</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame B (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.world2pix">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">world2pix</code><span class="sig-paren">(</span><em>hdr</em>, <em>dimx</em>, <em>dimy</em>, <em>star_list_deg</em>, <em>dxmap</em>, <em>dymap</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.world2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA/DEC coordinates to pixel positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – pyfits.Header instance</li>
<li><strong>dimx</strong> – Image dimension along X</li>
<li><strong>dimy</strong> – Image dimension along Y</li>
<li><strong>star_list_deg</strong> – List of star coordinates in degrees</li>
<li><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</li>
<li><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.err">
<span id="orb-utils-err-module"></span><h2>orb.utils.err module<a class="headerlink" href="#module-orb.utils.err" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="orb.utils.err.FitError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitError</code><a class="headerlink" href="#orb.utils.err.FitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.FitInitError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitInitError</code><a class="headerlink" href="#orb.utils.err.FitInitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.FitInputError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitInputError</code><a class="headerlink" href="#orb.utils.err.FitInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.ORBError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">ORBError</code><a class="headerlink" href="#orb.utils.err.ORBError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.RuntimeError</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.ValidationError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">ValidationError</code><a class="headerlink" href="#orb.utils.err.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fft">
<span id="orb-utils-fft-module"></span><h2>orb.utils.fft module<a class="headerlink" href="#module-orb.utils.fft" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.fft.apod2sigma">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apod2sigma</code><span class="sig-paren">(</span><em>apod</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the broadening of the gaussian-sinc function in the
spectrum for a given apodization level. Unit is that of the fwhm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>apod</strong> – Apodization level (must be &gt;= 1.)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.apod2width">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apod2width</code><span class="sig-paren">(</span><em>apod</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the gaussian window for a given apodization level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>apod</strong> – Apodization level (must be &gt;= 1.)</td>
</tr>
</tbody>
</table>
<p>The apodization level is the broadening factor of the line (an
apodization level of 2 mean that the line fwhm will be 2 times
wider).</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.border_cut_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">border_cut_window</code><span class="sig-paren">(</span><em>n</em>, <em>coeff=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Window length</li>
<li><strong>coeff</strong> – Border size in percentage of the total length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.cube_raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">cube_raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Interferogram cube</li>
<li><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.gaussian_window()</span></code> (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.gaussian_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">gaussian_window</code><span class="sig-paren">(</span><em>coeff</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.gaussian_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian apodization function for a given broadening
factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coeff</strong> – FWHM relative to the sinc function. Must be a float &gt; 1.</li>
<li><strong>x</strong> – Must be an axis defnined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.indft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">indft</code><span class="sig-paren">(</span><em>a</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – regularly sampled spectrum.</li>
<li><strong>x</strong> – positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.interf_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">interf_mean_energy</code><span class="sig-paren">(</span><em>interf</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interf</strong> – an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.learner95_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">learner95_window</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – Must be an axis defnined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.ndft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">ndft</code><span class="sig-paren">(</span><em>a</em>, <em>xk</em>, <em>vj</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.ndft" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-uniform Discret Fourier Tranform</p>
<p>Compute the spectrum from an interferogram. Note that the axis can
be irregularly sampled.</p>
<p>If the spectral axis (output axis) is irregular the result is
exact. But there is no magic: if the input axis (interferogram
sampling) is irregular the output spectrum is not exact because
the projection basis is not orthonormal.</p>
<p>If the interferogram is the addition of multiple regularly sampled
scans with a opd shift between each scan, the result will be good
as long as there are not too much scans added one after the
other. But if the interferogram steps are randomly distributed, it
will be better to use a classic FFT because the resulting noise
will be much lower.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – 1D interferogram</li>
<li><strong>xk</strong> – 1D sampling steps of the interferogram. Must have the
same size as a and must be relative to the real step length,
i.e. if the sampling is uniform xk = np.arange(a.size).</li>
<li><strong>vj</strong> – 1D frequency sampling of the output spectrum.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.next_power_of_two">
<code class="descclassname">orb.utils.fft.</code><code class="descname">next_power_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> – The number from which the next power of two has to be
computed. Can be an array of numbers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.norton_beer_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">norton_beer_window</code><span class="sig-paren">(</span><em>fwhm='1.6'</em>, <em>n=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id1">[NAY2007]</a>).</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm</strong> – FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default ‘1.6’)</li>
<li><strong>n</strong> – Number of points (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id2">[NAY2007]</a> :</p>
<table border="1" class="last docutils">
<colgroup>
<col width="8%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FWHM</td>
<td>C0</td>
<td>C1</td>
<td>C2</td>
<td>C4</td>
<td>C6</td>
<td>C8</td>
</tr>
<tr class="row-even"><td>1.1</td>
<td>0.701551</td>
<td>-0.639244</td>
<td>0.937693</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td>0.396430</td>
<td>-0.150902</td>
<td>0.754472</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td>0.237413</td>
<td>-0.065285</td>
<td>0.827872</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.4</td>
<td>0.153945</td>
<td>-0.141765</td>
<td>0.987820</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.5</td>
<td>0.077112</td>
<td>0.000000</td>
<td>0.703371</td>
<td>0.219517</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.6</td>
<td>0.039234</td>
<td>0.000000</td>
<td>0.630268</td>
<td>0.234934</td>
<td>0.095563</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.7</td>
<td>0.020078</td>
<td>0.000000</td>
<td>0.480667</td>
<td>0.386409</td>
<td>0.112845</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.8</td>
<td>0.010172</td>
<td>0.000000</td>
<td>0.344429</td>
<td>0.451817</td>
<td>0.193580</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.9</td>
<td>0.004773</td>
<td>0.000000</td>
<td>0.232473</td>
<td>0.464562</td>
<td>0.298191</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>2.0</td>
<td>0.002267</td>
<td>0.000000</td>
<td>0.140412</td>
<td>0.487172</td>
<td>0.256200</td>
<td>0.113948</td>
</tr>
</tbody>
</table>
</div>
<table class="docutils citation" frame="void" id="nay2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NAY2007]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em>, <em>inverse=False</em>, <em>return_complex=False</em>, <em>return_phase=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector.</p>
<p>Return the absolute value of the complex vector by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Interferogram.</li>
<li><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.norton_beer_window()</span></code> (default None)</li>
<li><strong>inverse</strong> – (Optional) If True compute the inverse FFT
(default False).</li>
<li><strong>return_complex</strong> – (Optional) If True, the complex vector is
returned (default False).</li>
<li><strong>return_phase</strong> – (Optional) If True, the phase is
returned.(default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.spectrum_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em>spectrum</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spectrum</strong> – a 1D spectrum</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.filters">
<span id="orb-utils-filters-module"></span><h2>orb.utils.filters module<a class="headerlink" href="#module-orb.utils.filters" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.filters.compute_weights">
<code class="descclassname">orb.utils.filters.</code><code class="descname">compute_weights</code><span class="sig-paren">(</span><em>calib</em>, <em>nm_laser</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>range_border_coeff</em>, <em>filter_min_cm1</em>, <em>filter_max_cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute weights for a fit based on a spectrum with a given
filter bandpass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib</strong> – Calibration laser observed wavelength</li>
<li><strong>nm_laser</strong> – Calibration laser theoretical wavelength</li>
<li><strong>step_nb</strong> – Vector length</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>range_border_coeff</strong> – Percentage of the vector size
considered as bad borders near the filter edges (must be between
0.2 and 0.).</li>
<li><strong>filter_min_cm1</strong> – Minimum wavenumber of the filter in cm-1</li>
<li><strong>filter_max_cm1</strong> – Maximum wavenumber of the filter in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fit">
<span id="orb-utils-fit-module"></span><h2>orb.utils.fit module<a class="headerlink" href="#module-orb.utils.fit" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.fit.gvardict2pickdict">
<code class="descclassname">orb.utils.fit.</code><code class="descname">gvardict2pickdict</code><span class="sig-paren">(</span><em>gvardict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.gvardict2pickdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dictionary containing gvars into a nice pickable
dictionary with couples of _mean / _sdev keys.</p>
<p>Use the pickdict2gvardict to rerturn to the original dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.paramslist2pick">
<code class="descclassname">orb.utils.fit.</code><code class="descname">paramslist2pick</code><span class="sig-paren">(</span><em>paramslist</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.paramslist2pick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.fit.pick2paramslist">
<code class="descclassname">orb.utils.fit.</code><code class="descname">pick2paramslist</code><span class="sig-paren">(</span><em>picklist</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pick2paramslist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.fit.pickdict2gvardict">
<code class="descclassname">orb.utils.fit.</code><code class="descname">pickdict2gvardict</code><span class="sig-paren">(</span><em>pickdict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pickdict2gvardict" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert gvardict2pickdict.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.sigma2vel">
<code class="descclassname">orb.utils.fit.</code><code class="descname">sigma2vel</code><span class="sig-paren">(</span><em>sigma</em>, <em>lines</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.sigma2vel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a broadening in channels to a velocity in km/s
:param sigma: broadening in channels
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.vel2sigma">
<code class="descclassname">orb.utils.fit.</code><code class="descname">vel2sigma</code><span class="sig-paren">(</span><em>vel</em>, <em>lines</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.vel2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a velocity in km/s to a broadening in channels.
:param vel: velocity in km/s
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.image">
<span id="orb-utils-image-module"></span><h2>orb.utils.image module<a class="headerlink" href="#module-orb.utils.image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.image.bf_laser_aligner">
<code class="descclassname">orb.utils.image.</code><code class="descname">bf_laser_aligner</code><span class="sig-paren">(</span><em>im1</em>, <em>im2</em>, <em>init_dx</em>, <em>init_dy</em>, <em>init_angle</em>, <em>zf</em>, <em>binning=4</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bf_laser_aligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two complementary laser frames (i.e. cam1 and cam2) with
a brute force algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im1</strong> – frame 1</li>
<li><strong>im2</strong> – frame 2</li>
<li><strong>init_dx</strong> – Initial alignement parameter along X axis</li>
<li><strong>init_dy</strong> – Initial alignement parameter along Y axis</li>
<li><strong>init_angle</strong> – Initial angle</li>
<li><strong>zf</strong> – Zoom factor</li>
<li><strong>binning</strong> – Binning of the data for the first pass</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function returns parameters much different that
the alignement parameters we get from stars… I don’t know why
!</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.bin_image">
<code class="descclassname">orb.utils.image.</code><code class="descname">bin_image</code><span class="sig-paren">(</span><em>a</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean binned image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> – 2d array to bin.</li>
<li><strong>binning</strong> – binning (must be an integer &gt;= 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only the complete sets of rows or columns are binned
so that depending on the bin size and the image size the
last columns or rows can be ignored. This ensures that the
binning surface is the same for every pixel in the binned
array.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.check_frames">
<code class="descclassname">orb.utils.image.</code><code class="descname">check_frames</code><span class="sig-paren">(</span><em>frames</em>, <em>sigma_reject=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Set of frames to check</li>
<li><strong>sigma_reject</strong> – (Optional) Rejection coefficient (default 2.5)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.compute_binning">
<code class="descclassname">orb.utils.image.</code><code class="descname">compute_binning</code><span class="sig-paren">(</span><em>image_shape</em>, <em>detector_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.compute_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return binning along both axis given the image shape and the
detector shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image_size</strong> – Tuple [x,y] giving the image shape</li>
<li><strong>detector_shape</strong> – Tuple [x,y] giving the detector shape
(i.e. maximum numbers of pixels along the x and y axis.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_cosmic_rays">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_cosmic_rays</code><span class="sig-paren">(</span><em>frame</em>, <em>cr_map</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_cosmic_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>correct cosmic rays in an image</p>
<p>CRs are replaced by a weighted average of the neighbouring
region. Weights are calculated from a 2d gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – image</li>
<li><strong>cr_map</strong> – cosmic ray map (1 = CR, 0 = NO_CR). must be of
boolean type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_hot_pixels">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_hot_pixels</code><span class="sig-paren">(</span><em>im</em>, <em>hp_map</em>, <em>box_size=3</em>, <em>std_filter_coeff=1.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_hot_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct hot pixels in an image given a map of their position.</p>
<p>The algorithm used replaces a hot pixel value by the median of the
pixels in a box around it. Pixels values which are not too much
different from the values around are not modified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to correct</li>
<li><strong>hp_map</strong> – Hot pixels map (1 for hot pixels, 0 for normal
pixel)</li>
<li><strong>box_size</strong> – (Optional) Size of the correction box (default
3).</li>
<li><strong>std_filter_coeff</strong> – (Optional) Coefficient on the std used to
check if the value of a hot pixel must be changed (default 1.5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_map2d</code><span class="sig-paren">(</span><em>map2d</em>, <em>bad_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map2d</strong> – The map to correct</li>
<li><strong>bad_value</strong> – (Optional) Value considered as bad (default
np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>silent=False</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Frames to combine.</li>
<li><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</li>
<li><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</li>
<li><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</li>
<li><strong>silent</strong> – (Optional) If True no information message are
displayed.</li>
<li><strong>check</strong> – (Optional) If True deviating frames are rejected
before combination (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.crop_pixel_positions">
<code class="descclassname">orb.utils.image.</code><code class="descname">crop_pixel_positions</code><span class="sig-paren">(</span><em>pixs</em>, <em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.crop_pixel_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned a croped list of pixels position</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.extract_elliptical_profile">
<code class="descclassname">orb.utils.image.</code><code class="descname">extract_elliptical_profile</code><span class="sig-paren">(</span><em>im</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em>, <em>n=20</em>, <em>percentile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.extract_elliptical_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the elliptical profile of a source</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>im</strong> – Image</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
<li><strong>n</strong> – (Optional) Number of divisions (default 20)</li>
<li><strong>percentile</strong> – (Optional) percentile instead of std. Return
(r, lmedian, [lmin, lmax]). Remember that the 1-sigma percentile
is 15.865 for a gaussian distribution (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first">Y position of the center</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (r, l, lerr) where r is the list of radiuses
along rX, l the mean luminosity in the ellipse portion
corresponding to the radius, lerr the standard deviation of the
luminosity in the same portion of the ellipse.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_calibration_laser_map</code><span class="sig-paren">(</span><em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em>, <em>mirror_distance_guess=240000.0</em>, <em>return_model_fit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a calibration laser map.</p>
<p>Fit an opto-mechanical model first and uses Zernike polynomials to
fit the residual wavefront error.</p>
<p>The model is based on optical parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib_laser_map</strong> – Reference calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Wavelength of the calibration laser in nm.</li>
<li><strong>pixel_size</strong> – (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><strong>binning</strong> – (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
<li><strong>mirror_distance_guess</strong> – (Optional) Guess on the mirror
distance in um (default 2.2e5).</li>
<li><strong>return_model_fit</strong> – (Optional) If True the optical model fit
is also returned (i.e. without the wavefront modeling with Zernike
polynomials) (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_highorder_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_highorder_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>err_map</em>, <em>calib_map</em>, <em>nm_laser</em>, <em>knb=10</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_highorder_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Robust fit phase maps of order &gt; 1</p>
<p>Uses a theta dependant fit model base on a spline. See
py:meth:<cite>utils.fit_map_cos</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phase_map</strong> – Phase map to fit</li>
<li><strong>err_map</strong> – Error map of phase map values</li>
<li><strong>calib_map</strong> – Calibration laser map.</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple: (Fitted map, residual map)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>smooth_deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit map with low order polynomials</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_map</strong> – data map</li>
<li><strong>err_map</strong> – error map</li>
<li><strong>smooth_deg</strong> – Degree of fit smoothing (beware of high
smoothing degrees)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple: (fitted data map, residual map, fit RMS error)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map_theta">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map_theta</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>theta_map</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>fit any data map with respect to theta. Given the corresponding theta map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_map</strong> – Data map to fit</li>
<li><strong>err_map</strong> – Uncertainty on the data map</li>
<li><strong>theta_map</strong> – Theta map (in degree)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map_zernike">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map_zernike</code><span class="sig-paren">(</span><em>data_map</em>, <em>weights_map</em>, <em>nmodes</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_zernike" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a map with Zernike polynomials.</p>
<p>Bad values must be set to NaN (not 0.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_map</strong> – Data map to fit</li>
<li><strong>weights_map</strong> – weights map (high weight value stands for high
precision data)</li>
<li><strong>nmodes</strong> – Number of zernike modes to use for fitting.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(fitted data map, error map, fit error)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_phase_map02calib_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_phase_map02calib_map</code><span class="sig-paren">(</span><em>calib</em>, <em>pm0</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_phase_map02calib_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the best transformation parameters that permit to
compute an order 0 phase map from a calibration laser map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib</strong> – Calibration laser map</li>
<li><strong>pm0</strong> – Order 0 phase map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_sitelle_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_sitelle_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>phase_map_err</em>, <em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em>, <em>return_coeffs=False</em>, <em>wavefront_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_sitelle_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a SITELLE phase map (order 0 map of the phase) using a
model based on a simulated calibration laser map.</p>
<p>A real calibration laser map is needed first to get an initial guess
on the parameters of the fit. Then the whole phase map is modeled
to fit the real phase map.</p>
<p>The modeled calibration laser map obtained from the fit is also
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phase_map</strong> – Phase map to fit.</li>
<li><strong>phase_map_err</strong> – Error on the phase map values.</li>
<li><strong>calib_laser_map</strong> – Reference calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Wavelength of the calibration laser in nm.</li>
<li><strong>pixel_size</strong> – (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><strong>binning</strong> – (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
<li><strong>return_coeffs</strong> – (Optional) If True, transformation
coefficients are returned also (default False).</li>
<li><strong>wavefront_map</strong> – (Optional) Residual between the modeled
calibration laser map and the real laser map. This residual can
generally be fitted with Zernike polynomials. If given, the
wavefront is considered stable and is removed before the model
is fitted (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (fitted phase map, error map, fit error, new
calibration laser map) + a tuple of transformation coefficients
(a0 and a1) if return_coeffs is True.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.get_box_coords">
<code class="descclassname">orb.utils.image.</code><code class="descname">get_box_coords</code><span class="sig-paren">(</span><em>ix</em>, <em>iy</em>, <em>box_size</em>, <em>x_lim_min</em>, <em>x_lim_max</em>, <em>y_lim_min</em>, <em>y_lim_max</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ix</strong> – center of the box along x axis</li>
<li><strong>iy</strong> – center of the box along y axis</li>
<li><strong>box_size</strong> – Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><strong>x_lim_min</strong> – Minimum limit of the range along x.</li>
<li><strong>x_lim_max</strong> – Maximum limit of the range along x.</li>
<li><strong>y_lim_min</strong> – Minimum limit of the range along y.</li>
<li><strong>y_lim_max</strong> – Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x_min, x_max, y_min, y_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_diff_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_diff_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to filter</li>
<li><strong>deg</strong> – (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_image_filter</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>im</strong> – Image to filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.in_ellipse">
<code class="descclassname">orb.utils.image.</code><code class="descname">in_ellipse</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.in_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is in the ellipse or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – X position of the point</li>
<li><strong>y</strong> – Y position of the point</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first last">Y position of the center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.interpolate_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">interpolate_map</code><span class="sig-paren">(</span><em>m</em>, <em>dimx</em>, <em>dimy</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<p>This function is robust to Nans.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The interpolation process is much longer if Nans are
present in the map.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Map</li>
<li><strong>dimx</strong> – X dimension of the result</li>
<li><strong>dimy</strong> – Y dimension of the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.low_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">low_pass_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to filter</li>
<li><strong>deg</strong> – Radius of the kernel. Must be &gt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.nanbin_image">
<code class="descclassname">orb.utils.image.</code><code class="descname">nanbin_image</code><span class="sig-paren">(</span><em>im</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image (or cube) binning robust to NaNs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image or cube to bin</li>
<li><strong>binning</strong> – Binning factor (must be an integer)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">adapted from <a class="reference external" href="https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy">https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy</a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.on_ellipse">
<code class="descclassname">orb.utils.image.</code><code class="descname">on_ellipse</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em>, <em>e=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.on_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is on the ellipse or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – X position of the point</li>
<li><strong>y</strong> – Y position of the point</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
<li><strong>e</strong> – (Optional) Precision in pixels (default 0.5).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first last">Y position of the center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.polar_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">polar_map2d</code><span class="sig-paren">(</span><em>f</em>, <em>n</em>, <em>corner=False</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> – The function to map.</li>
<li><strong>n</strong> – Matrix size. Can be a couple of integers (nx, ny).</li>
<li><strong>corner</strong> – (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</li>
<li><strong>circle</strong> – (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.pp_create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">pp_create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>ncpus=0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Frames to combine.</li>
<li><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</li>
<li><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</li>
<li><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.shift_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">shift_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>dx</em>, <em>dy</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>order</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame wit the same dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Two dimensions array to be shifted</li>
<li><strong>dx</strong> – Shift value along the axis 0</li>
<li><strong>dy</strong> – Shift value along the axis 1</li>
<li><strong>x_max</strong><strong>, </strong><strong>y_min</strong><strong>, </strong><strong>y_max</strong> (<em>x_min</em><em>,</em>) – Boundaries of the region to be
shifted.</li>
<li><strong>order</strong> – interpolation order.</li>
<li><strong>(</strong><strong>Optional</strong><strong>)</strong> (<em>fill_value</em>) – Value of the extrapolated points
(default np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.simulate_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">simulate_calibration_laser_map</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>pixel_size</em>, <em>mirror_distance</em>, <em>theta_cx</em>, <em>theta_cy</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em>, <em>calib_laser_nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a calibration laser map from optical and mechanical
parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Number of pixels along X</li>
<li><strong>ny</strong> – Number of pixels along Y</li>
<li><strong>pixel_size</strong> – Size of a pixel in microns</li>
<li><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</li>
<li><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</li>
<li><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</li>
<li><strong>phi_x</strong> – Tilt of the mirror along X in degrees</li>
<li><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</li>
<li><strong>phi_r</strong> – Rotation angle of the camera in degrees</li>
<li><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.simulate_theta_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">simulate_theta_map</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>pixel_size</em>, <em>mirror_distance</em>, <em>theta_cx</em>, <em>theta_cy</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_theta_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate incident angle (theta) map from optical and mechanical
parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Number of pixels along X</li>
<li><strong>ny</strong> – Number of pixels along Y</li>
<li><strong>pixel_size</strong> – Size of a pixel in microns</li>
<li><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</li>
<li><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</li>
<li><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</li>
<li><strong>phi_x</strong> – Tilt of the mirror along X in degrees</li>
<li><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</li>
<li><strong>phi_r</strong> – Rotation angle of the camera in degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.tilt_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">tilt_calibration_laser_map</code><span class="sig-paren">(</span><em>cmap</em>, <em>calib_laser_nm</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.tilt_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Tilt and rotate a calibration laser map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cmap</strong> – calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm.</li>
<li><strong>phi_x</strong> – tilt angle along X axis (degrees).</li>
<li><strong>phi_y</strong> – tilt angle along Y axis (degrees).</li>
<li><strong>phi_r</strong> – Rotation angle (degrees).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.transform_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">transform_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>d</em>, <em>rc</em>, <em>zoom_factor</em>, <em>interp_order</em>, <em>mask=None</em>, <em>fill_value=nan</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame to transform</li>
<li><strong>x_min</strong> – Lower x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>x_max</strong> – Upper x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>y_min</strong> – Lower y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>y_max</strong> – Upper y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>d</strong> – Transformation coefficients [dx, dy, dr, da, db]</li>
<li><strong>rc</strong> – Rotation center of the frame [rc_x, rc_y]</li>
<li><strong>zoom_factor</strong> – Zoom on the image. Can be a couple (zx, zy).</li>
<li><strong>interp_order</strong> – Interpolation order</li>
<li><strong>mask</strong> – (Optional) If a mask frame is passed it is
transformed also (default None).</li>
<li><strong>fill_value</strong> – (Optional) Fill value for extrapolated points
(default np.nan).</li>
<li><strong>sip_A</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the output image (default None).</li>
<li><strong>sip_B</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the input image (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.unwrap_phase_map0">
<code class="descclassname">orb.utils.image.</code><code class="descname">unwrap_phase_map0</code><span class="sig-paren">(</span><em>phase_map</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.unwrap_phase_map0" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase is defined modulo pi/2. The Unwrapping is a
reconstruction of the phase so that the distance between two
neighbour pixels is always less than pi/4. Then the real
phase pattern can be recovered and fitted easily.</p>
<p>The idea is the same as with np.unwrap() but in 2D, on a
possibly very noisy map, where a naive 2d unwrapping cannot
be done.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>phase_map</strong> – Order 0 phase map.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.io">
<span id="orb-utils-io-module"></span><h2>orb.utils.io module<a class="headerlink" href="#module-orb.utils.io" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.io.array2dict">
<code class="descclassname">orb.utils.io.</code><code class="descname">array2dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.array2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array read from an hdf5 file to a dict.
:param data: array of params returned by dict2array</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.cast">
<code class="descclassname">orb.utils.io.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>a</em>, <em>t_str</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.io.cast2hdf5">
<code class="descclassname">orb.utils.io.</code><code class="descname">cast2hdf5</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast2hdf5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.io.cast_storing_dtype">
<code class="descclassname">orb.utils.io.</code><code class="descname">cast_storing_dtype</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast_storing_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.io.dict2array">
<code class="descclassname">orb.utils.io.</code><code class="descname">dict2array</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.dict2array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dictionary to an array that can be written in an hdf5 file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> – Must be a dict instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.dict2header">
<code class="descclassname">orb.utils.io.</code><code class="descname">dict2header</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.dict2header" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a dict to a pyfits.Header() instance</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">this is a destructive process, illegal values are</p>
</div>
<p>removed from the header.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> – a dict instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_hdu_data_index">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_hdu_data_index</code><span class="sig-paren">(</span><em>hdul</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_hdu_data_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first header data unit (HDU) containing data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdul</strong> – A pyfits.HDU instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_sitelle_slice">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_sitelle_slice</code><span class="sig-paren">(</span><em>slice_str</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_sitelle_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip a string containing SITELLE like slice coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>slice_str</strong> – Slice string.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_storing_dtype">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_storing_dtype</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_storing_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.io.header_fits2hdf5">
<code class="descclassname">orb.utils.io.</code><code class="descname">header_fits2hdf5</code><span class="sig-paren">(</span><em>fits_header</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.header_fits2hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a pyfits.Header() instance to a header for an hdf5 file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fits_header</strong> – Header of the FITS file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.header_hdf52fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">header_hdf52fits</code><span class="sig-paren">(</span><em>hdf5_header</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.header_hdf52fits" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an hdf5 header to a pyfits.Header() instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdf5_header</strong> – Header of the HDF5 file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.load_dflist">
<code class="descclassname">orb.utils.io.</code><code class="descname">load_dflist</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.load_dflist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a list of dataframes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – path to the output file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.open_file">
<code class="descclassname">orb.utils.io.</code><code class="descname">open_file</code><span class="sig-paren">(</span><em>file_name</em>, <em>mode='r'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.open_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file in write mode (by default) and return a file
object.</p>
<p>Create the file if it doesn’t exist (only in write mode).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_name</strong> – Path to the file, can be either
relative or absolute.</li>
<li><strong>mode</strong> – (Optional) Can be ‘w’ for write mode, ‘r’ for
read mode and ‘a’ for append mode.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.open_hdf5">
<code class="descclassname">orb.utils.io.</code><code class="descname">open_hdf5</code><span class="sig-paren">(</span><em>file_path</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="xref py py-class docutils literal notranslate"><span class="pre">h5py.File</span></code> instance with some
informations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the hdf5 file.</li>
<li><strong>mode</strong> – Opening mode. Can be ‘r’, ‘r+’, ‘w’, ‘w-‘, ‘x’,
‘a’.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>no_error=False</em>, <em>nan_filter=False</em>, <em>return_header=False</em>, <em>return_hdu_only=False</em>, <em>return_mask=False</em>, <em>silent=False</em>, <em>delete_after=False</em>, <em>data_index=0</em>, <em>image_mode='classic'</em>, <em>chip_index=None</em>, <em>binning=None</em>, <em>fix_header=True</em>, <em>dtype=&lt;type 'float'&gt;</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a FITS data file and returns its data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</li>
<li><strong>no_error</strong> – (Optional) If True this function will only
display a warning message if the file does not exist (so it
does not raise an exception) (default False)</li>
<li><strong>nan_filter</strong> – (Optional) If True replace NaN by zeros
(default False)</li>
<li><strong>return_header</strong> – (Optional) If True return a tuple (data,
header) (default False).</li>
<li><strong>return_hdu_only</strong> – (Optional) If True return FITS header
data unit only. No data will be returned (default False).</li>
<li><strong>return_mask</strong> – (Optional) If True return only the mask
corresponding to the data file (default False).</li>
<li><strong>silent</strong> – (Optional) If True no message is displayed
except if an error is raised (default False).</li>
<li><strong>delete_after</strong> – (Optional) If True delete file after
reading (default False).</li>
<li><strong>data_index</strong> – (Optional) Index of data in the header data
unit (Default 0).</li>
<li><strong>image_mode</strong> – (Optional) Can be ‘sitelle’, ‘spiomm’ or
‘classic’. In ‘sitelle’ mode, the parameter
chip_index must also be set to 0 or 1. In this mode only
one of both SITELLE quadrants is returned. In ‘classic’ mode
the whole frame is returned (default ‘classic’).</li>
<li><strong>chip_index</strong> – (Optional) Index of the chip of the
SITELLE image. Used only if image_mode is set to ‘sitelle’
In this case, must be 1 or 2. Else must be None (default
None).</li>
<li><strong>binning</strong> – (Optional) If not None, returned data is
binned by this amount (must be an integer &gt;= 1)</li>
<li><strong>fix_header</strong> – (Optional) If True, fits header is
fixed to avoid errors due to header inconsistencies
(e.g. WCS errors) (default True).</li>
<li><strong>dtype</strong> – (Optional) Data is converted to
the given dtype (e.g. np.float32, default float).</li>
<li><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module. And
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_hdf5">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_hdf5</code><span class="sig-paren">(</span><em>file_path</em>, <em>return_header=False</em>, <em>dtype=&lt;type 'float'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an HDF5 data file created with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Tools.write_hdf5()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file, can be either
relative or absolute.</li>
<li><strong>return_header</strong> – (Optional) If True return a tuple (data,
header) (default False).</li>
<li><strong>dtype</strong> – (Optional) Data is converted to the given type
(e.g. np.float32, default float).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_sitelle_chip">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_sitelle_chip</code><span class="sig-paren">(</span><em>hdu</em>, <em>chip_index</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_sitelle_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return chip data of a SITELLE FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdu</strong> – pyfits.HDU Instance of the SITELLE image</li>
<li><strong>chip_index</strong> – Index of the chip to read. Must be 1 or 2.</li>
<li><strong>substract_bias</strong> – If True bias is automatically
substracted by using the overscan area (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_spiomm_data">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_spiomm_data</code><span class="sig-paren">(</span><em>hdu</em>, <em>image_path</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_spiomm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data of an SpIOMM FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdu</strong> – pyfits.HDU Instance of the SpIOMM image</li>
<li><strong>image_path</strong> – Image path</li>
<li><strong>substract_bias</strong> – If True bias is automatically
substracted by using the associated bias frame as an
overscan frame. Mean bias level is thus computed along the y
axis of the bias frame (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_votable">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_votable</code><span class="sig-paren">(</span><em>votable_file</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_votable" title="Permalink to this definition">¶</a></dt>
<dd><p>read a votable and transfer it as as pandas dataframe.</p>
<p>taken from <a class="reference external" href="https://gist.github.com/icshih/52ca49eb218a2d5b660ee4a653301b2b">https://gist.github.com/icshih/52ca49eb218a2d5b660ee4a653301b2b</a></p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.save_dflist">
<code class="descclassname">orb.utils.io.</code><code class="descname">save_dflist</code><span class="sig-paren">(</span><em>dflist</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.save_dflist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a list of dataframes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dflist</strong> – list of pandas dataframes</li>
<li><strong>path</strong> – path to the output file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.save_starlist">
<code class="descclassname">orb.utils.io.</code><code class="descname">save_starlist</code><span class="sig-paren">(</span><em>path</em>, <em>starlist</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.save_starlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a star list as a two columnfile X, Y readable by ds9</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.write_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">write_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>fits_data</em>, <em>fits_header=None</em>, <em>silent=False</em>, <em>overwrite=True</em>, <em>mask=None</em>, <em>replace=False</em>, <em>record_stats=False</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in FITS format. If the file doesn’t exist create
it with its directories.</p>
<p>If the file already exists add a number to its name before the
extension (unless ‘overwrite’ option is set to True).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</li>
<li><strong>fits_data</strong> – Data to be written in the file.</li>
<li><strong>fits_header</strong> – (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), …]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed.</li>
<li><strong>silent</strong> – (Optional) If True turn this function won’t
display any message (default False)</li>
<li><strong>overwrite</strong> – (Optional) If True overwrite the output file
if it exists (default True).</li>
<li><strong>mask</strong> – (Optional) It not None must be an array with the
same size as the given data but filled with ones and
zeros. Bad values (NaN or Inf) are converted to 1 and the
array is converted to 8 bit unsigned integers (uint8). This
array will be written to the disk with the same path
terminated by ‘_mask’. The header of the mask FITS file will
be the same as the original data (default None).</li>
<li><strong>replace</strong> – (Optional) If True and if the file already
exist, new data replace old data in the existing file. NaN
values do not replace old values. Other values replace old
values. New array MUST have the same size as the existing
array. Note that if replace is True, overwrite is
automatically set to True.</li>
<li><strong>record_stats</strong> – (Optional) If True, record mean and
median of data. Useful if they often have to be computed
(default False).</li>
<li><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">float64 data is converted to float32 data to avoid
too big files with unnecessary precision</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module and
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.write_hdf5">
<code class="descclassname">orb.utils.io.</code><code class="descname">write_hdf5</code><span class="sig-paren">(</span><em>file_path</em>, <em>data</em>, <em>header=None</em>, <em>silent=False</em>, <em>overwrite=True</em>, <em>max_hdu_check=True</em>, <em>compress=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in HDF5 format.</p>
<p>A header can be added to the data. This method is useful to
handle an HDF5 data file like a FITS file. It implements most
of the functionality of the method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Tools.write_fits()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The output HDF5 file can contain mutiple data header
units (HDU). Each HDU is in a specific group named ‘hdu*’, *
being the index of the HDU. The first HDU is named
HDU0. Each HDU contains one data group (HDU*/data) which
contains a numpy.ndarray and one header group
(HDU*/header). Each subgroup of a header group is a keyword
and its associated value, comment and type.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the HDF5 file to create</li>
<li><strong>data</strong> – A numpy array (numpy.ndarray instance) of numeric
values. If a list of arrays is given, each array will be
placed in a specific HDU. The header keyword must also be
set to a list of headers of the same length.</li>
<li><strong>header</strong> – (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), …]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed (default
None). It can also be a list of headers if a list of arrays
has been passed to the option ‘data’.</li>
<li><strong>max_hdu_check</strong> – (Optional): When True, if the input data
is a list (interpreted as a list of data unit), check if
it’s length is not too long to make sure that the input list
is not a single data array that has not been converted to a
numpy.ndarray format. If the number of HDU to create is
indeed very long this can be set to False (default True).</li>
<li><strong>silent</strong> – (Optional) If True turn this function won’t
display any message (default False)</li>
<li><strong>overwrite</strong> – (Optional) If True overwrite the output file
if it exists (default True).</li>
<li><strong>compress</strong> – (Optional) If True data is compressed using
the SZIP library (see
<a class="reference external" href="https://www.hdfgroup.org/doc_resource/SZIP/">https://www.hdfgroup.org/doc_resource/SZIP/</a>). SZIP library
must be installed (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.log">
<span id="orb-utils-log-module"></span><h2>orb.utils.log module<a class="headerlink" href="#module-orb.utils.log" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.log.print_caller_traceback">
<code class="descclassname">orb.utils.log.</code><code class="descname">print_caller_traceback</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.log.print_caller_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the traceback of the calling function.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.log.setup_socket_logging">
<code class="descclassname">orb.utils.log.</code><code class="descname">setup_socket_logging</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.log.setup_socket_logging" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-orb.utils.misc">
<span id="orb-utils-misc-module"></span><h2>orb.utils.misc module<a class="headerlink" href="#module-orb.utils.misc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.misc.aggregate_pixels">
<code class="descclassname">orb.utils.misc.</code><code class="descname">aggregate_pixels</code><span class="sig-paren">(</span><em>pixel_list</em>, <em>radius=1.42</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.aggregate_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate neighbouring pixels into a set of sources. Two
neighbours are found if there distance is smaller than a given
radius (in pixels).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pixel_list</strong> – A list of pixel position as returned by a
function like numpy.nonzero.</li>
<li><strong>radius</strong> – (Optional) Max separation between two pixels of the
same source (default 1.42).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of pixel list. Each item of the list corresponds
to a source and each source is itself a list of pixel positions
(x,y).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.compute_obs_params">
<code class="descclassname">orb.utils.misc.</code><code class="descname">compute_obs_params</code><span class="sig-paren">(</span><em>nm_min_filter</em>, <em>nm_max_filter</em>, <em>theta_min=5.01</em>, <em>theta_max=11.28</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nm_min_filter</strong> – Min wavelength of the filter in nm.</li>
<li><strong>nm_max_filter</strong> – Max wavelength of the filter in nm.</li>
<li><strong>theta_min</strong> – (Optional) Min angle of the detector (default
5.01).</li>
<li><strong>theta_max</strong> – (Optional) Max angle of the detector (default
11.28).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (order, step size, max wavelength)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.convert_camera_parameter">
<code class="descclassname">orb.utils.misc.</code><code class="descname">convert_camera_parameter</code><span class="sig-paren">(</span><em>param</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.convert_camera_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert camera parameter to an integer value</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.correct_bad_frames_vector">
<code class="descclassname">orb.utils.misc.</code><code class="descname">correct_bad_frames_vector</code><span class="sig-paren">(</span><em>bad_frames_vector</em>, <em>dimz</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bad_frames_vector</strong> – The vector of indexes to correct</li>
<li><strong>dimz</strong> – Dimension of the cube along the 3rd axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_axis_from_hdr">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_axis_from_hdr</code><span class="sig-paren">(</span><em>hdr</em>, <em>axis_index=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_axis_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return axis from a classic FITS header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – FITS header</li>
<li><strong>axis_index</strong> – (Optional) Index of the axis to retrieve
(default 1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_cfht_odometer">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_cfht_odometer</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_cfht_odometer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the odometer of a cfht FITS file from its path.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_mask_from_ds9_region_file">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_mask_from_ds9_region_file</code><span class="sig-paren">(</span><em>reg_path</em>, <em>x_range</em>, <em>y_range</em>, <em>integrate=True</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mask from a ds9 region file or from a ds9-like region
string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reg_path</strong> – Path to a ds9 region file or ds9-like region string</li>
<li><strong>x_range</strong> – Range of x image coordinates
considered as valid. Pixels outside this range are
rejected..</li>
<li><strong>y_range</strong> – Range of y image coordinates
considered as valid. Pixels outside this range are
rejected.</li>
<li><strong>integrate</strong> – (Optional) If True, all pixels are integrated
into one mask, else a list of region masks is returned (default
True)</li>
<li><strong>header</strong> – (Optional) Header containing the WCS transformation
if the region file is in celestial coordinates (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be celestial or image coordinates
(x,y). if coordinates are celestial a header must be passed to
the function.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.read_instrument_value_from_file">
<code class="descclassname">orb.utils.misc.</code><code class="descname">read_instrument_value_from_file</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.read_instrument_value_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the instrument value form an hdf5/fits file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – path to an hdf5/fits file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.restore_error_settings">
<code class="descclassname">orb.utils.misc.</code><code class="descname">restore_error_settings</code><span class="sig-paren">(</span><em>old_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.sort_image_list">
<code class="descclassname">orb.utils.misc.</code><code class="descname">sort_image_list</code><span class="sig-paren">(</span><em>file_list</em>, <em>image_mode</em>, <em>cube=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.sort_image_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort a list of fits files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_list</strong> – A list of file names</li>
<li><strong>image_mode</strong> – Image mode, can be ‘sitelle’ or ‘spiomm’.</li>
<li><strong>cube</strong> – If True, image list is considered as a cube
list. Headers are used to get the right order based on step
number instead of file path (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.parallel">
<span id="orb-utils-parallel-module"></span><h2>orb.utils.parallel module<a class="headerlink" href="#module-orb.utils.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.parallel.close_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">close_pp_server</code><span class="sig-paren">(</span><em>js</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.close_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy the parallel python job server to avoid too much
opened files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>js</strong> – job server.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.get_stats_str">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">get_stats_str</code><span class="sig-paren">(</span><em>js</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.get_stats_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return job server statistics as a string</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.init_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">init_pp_server</code><span class="sig-paren">(</span><em>ncpus=0</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.init_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a server for parallel processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ncpus</strong> – (Optional) Number of cpus to use. 0 means use all
available cpus (default 0)</li>
<li><strong>silent</strong> – (Optional) If silent no message is printed
(Default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.timed_process">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">timed_process</code><span class="sig-paren">(</span><em>func</em>, <em>timeout</em>, <em>args=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.timed_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a timed process which terminates after timeout seconds if it
does not return before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> – Timed func which will be terminated after timeout
seconds. must be func(<a href="#id3"><span class="problematic" id="id4">*</span></a>args, returned_dict). The
results of the function must be put in returned_dict.</li>
<li><strong>timeout</strong> – Timeout in s.</li>
<li><strong>args</strong> – arguments of the function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">returned_dict</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">from <a class="reference external" href="https://stackoverflow.com/questions/492519/timeout-on-a-function-call">https://stackoverflow.com/questions/492519/timeout-on-a-function-call</a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.photometry">
<span id="orb-utils-photometry-module"></span><h2>orb.utils.photometry module<a class="headerlink" href="#module-orb.utils.photometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.photometry.ABmag2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2flambda</code><span class="sig-paren">(</span><em>ABmag</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ABmag</strong> – A magnitude in the AB magnitude system</li>
<li><strong>lam</strong> – Wavelength in angstrom</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.ABmag2fnu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2fnu</code><span class="sig-paren">(</span><em>ABmag</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ABmag</strong> – A magnitude in the AB magnitude system</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_equivalent_bandwidth">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_equivalent_bandwidth</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_equivalent_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent bandwidth of a given filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Filter transmission axis in nm.</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_flux_calibration_vector">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_flux_calibration_vector</code><span class="sig-paren">(</span><em>re_spectrum</em>, <em>th_spectrum</em>, <em>std_step</em>, <em>std_order</em>, <em>std_exp_time</em>, <em>std_corr</em>, <em>filter_min_pix</em>, <em>filter_max_pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_flux_calibration_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the flux calibration vector from an observed spectrum
and the standard spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>re_spectrum</strong> – Observed spectrum in wavenumber.</li>
<li><strong>th_spectrum</strong> – standard spectrum (in erg/cm2/s/A) in wavenumber.</li>
<li><strong>std_step</strong> – Standard step size (in nm)</li>
<li><strong>std_order</strong> – Standard folding order</li>
<li><strong>std_exp_time</strong> – Standard Exposition time</li>
<li><strong>std_corr</strong> – Standard Correction coeff.</li>
<li><strong>filter_min_pix</strong> – Filter min position in pixels</li>
<li><strong>filter_max_pix</strong> – Filter max position in pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean energy of the photons passing thourgh a given
filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Filter transmission axis in nm.</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_star_flux">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_star_flux</code><span class="sig-paren">(</span><em>star_spectrum</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_star_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean star flux given a spectrum and the filter. Both
files must be given along the same wavelength/wavenumber axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_spectrum</strong> – Spectrum of the star</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_optimal_texp">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_optimal_texp</code><span class="sig-paren">(</span><em>star_flux</em>, <em>seeing</em>, <em>plate_scale</em>, <em>saturation=30000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_optimal_texp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the optimal exposure time given the total flux of the
star in ADU/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_flux</strong> – Total star flux in ADU/s</li>
<li><strong>seeing</strong> – Star FWHM in arcsec</li>
<li><strong>plate_scale</strong> – Size of 1 pixel in arcsec.</li>
<li><strong>saturation</strong> – (Optional) Saturation value (default 30000).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the photon energy computed for all the wavelength along
a given wavelength axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm_axis</strong> – Wavelength axis in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_star_central_pixel_value">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_star_central_pixel_value</code><span class="sig-paren">(</span><em>seeing</em>, <em>plate_scale</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_central_pixel_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative value of the pixel containing the greatest
proportion of the flux (central pixel) of Gaussian star.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>seeing</strong> – Star FWHM in arcsec</li>
<li><strong>plate_scale</strong> – Size of the pixels in arcsec.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.convert_cm1_flux2fluxdensity">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">convert_cm1_flux2fluxdensity</code><span class="sig-paren">(</span><em>a</em>, <em>cm1_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.convert_cm1_flux2fluxdensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a spectrum in X/s to X/s/A (X may be ADU or erg/cm^2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – spectrum</li>
<li><strong>cm1_axis</strong> – Axis of the spectrum in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.ext2trans">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ext2trans</code><span class="sig-paren">(</span><em>ext</em>, <em>airmass</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ext2trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert extinction to transmission</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ext</strong> – extinction</li>
<li><strong>airmass</strong> – airmass</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fit_std_spectrum">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fit_std_spectrum</code><span class="sig-paren">(</span><em>real_spectrum</em>, <em>std_spectrum</em>, <em>polydeg=2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fit_std_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a real spectrum multiplied by a polynomial over a standard
spectrum.</p>
<p>Return the polynomial which can be used directly as a calibration
curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>real_spectrum</strong> – Observed spectrum</li>
<li><strong>std_spectrum</strong> – Standard spectrum</li>
<li><strong>polydeg</strong> – Degree of the polynomial</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.flambda2ABmag">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">flambda2ABmag</code><span class="sig-paren">(</span><em>flambda</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.flambda2ABmag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return AB magnitude from flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>flambda</strong> – Flux in erg/cm2/s/A. Can be an array.</li>
<li><strong>lambda</strong> – Wavelength in A of the Flux. If flambda is an array
lambda must have the same shape.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fnu2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fnu2flambda</code><span class="sig-paren">(</span><em>fnu</em>, <em>nu</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fnu</strong> – Flux in erg/cm2/s/Hz</li>
<li><strong>nu</strong> – frequency in Hz</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.lambda2nu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">lambda2nu</code><span class="sig-paren">(</span><em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lam</strong> – Wavelength in angstrom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.modulation_efficiency_opd_jitter">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">modulation_efficiency_opd_jitter</code><span class="sig-paren">(</span><em>cm1</em>, <em>opd_jitter</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.modulation_efficiency_opd_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ME given the OPD jitter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1</strong> – wavenumber in cm-1</li>
<li><strong>opd_jitter</strong> – OPD jitter in nm (standard deviation)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.modulation_efficiency_wavefront_error">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">modulation_efficiency_wavefront_error</code><span class="sig-paren">(</span><em>cm1</em>, <em>wferr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.modulation_efficiency_wavefront_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ME given the OPD jitter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1</strong> – wavenumber in cm-1</li>
<li><strong>wferr</strong> – wavefront error ratio (e.g. 1/30.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.sim">
<span id="orb-utils-sim-module"></span><h2>orb.utils.sim module<a class="headerlink" href="#module-orb.utils.sim" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.sim.fft">
<code class="descclassname">orb.utils.sim.</code><code class="descname">fft</code><span class="sig-paren">(</span><em>interf</em>, <em>zp_coeff=2</em>, <em>apod=None</em>, <em>phase=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic Fourier Transform with zero-padding.</p>
<p>Useful to compute a quick assumption-less FFT.</p>
<p>ZPD is assumed to be on the first sample of the interferogram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>interf</strong> – interferogram</li>
<li><strong>zp_coeff</strong> – Zero-padding coefficient (2 by default)</li>
<li><strong>apod</strong> – Apodization function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">axis, complex interferogram FFT</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.sim.line_interf">
<code class="descclassname">orb.utils.sim.</code><code class="descname">line_interf</code><span class="sig-paren">(</span><em>sigma</em>, <em>step_nb</em>, <em>phi=0</em>, <em>symm=False</em>, <em>jitter=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.line_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a simple line interferogram (a cosine)</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> – line frequency (must be &lt; step_nb/2)</li>
<li><strong>step_nb</strong> – Length of the interferogram</li>
<li><strong>phi</strong> – (Optional) Phase of the line (in radians) (default 0).</li>
<li><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</li>
<li><strong>jitter</strong> – (Optional) Std of an OPD jitter. Must be a float
between 0 and 1 (jitter distribution is normal, default 0.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.sim.step_interf">
<code class="descclassname">orb.utils.sim.</code><code class="descname">step_interf</code><span class="sig-paren">(</span><em>sigma_min</em>, <em>sigma_max</em>, <em>step_nb</em>, <em>symm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.step_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a step interferogram</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma_ax</strong> – max frequency of the step (must be &lt; step_nb/2)</li>
<li><strong>step_nb</strong> – Length of the interferogram</li>
<li><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">results are much better with a symmetric interferogram
but ZPD is not on the first sample and the spectrum must thus be
phase corrected.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.spectrum">
<span id="orb-utils-spectrum-module"></span><h2>orb.utils.spectrum module<a class="headerlink" href="#module-orb.utils.spectrum" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.spectrum.amp_ratio_from_flux_ratio">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">amp_ratio_from_flux_ratio</code><span class="sig-paren">(</span><em>line0_cm1</em>, <em>line1_cm1</em>, <em>flux_ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.amp_ratio_from_flux_ratio" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return the amplitude ratio (amp(line0) / amp(line1)) from the flux</dt>
<dd>ratio (at constant fwhm and broadening).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>line0</strong> – Wavenumber of the line 0 (in cm-1).</li>
<li><strong>line1</strong> – Wavenumber of the line 1 (in cm-1).</li>
<li><strong>flux_ratio</strong> – Flux ratio: flux(line0) / flux(line1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12nm</code><span class="sig-paren">(</span><em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a wavelength in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cm1</strong> – wavenumber in cm-1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.cm12pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12pix</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1_axis</strong> – Axis in cm-1</li>
<li><strong>cm1</strong> – Wavenumber in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>apod_coeff=1.0</em>, <em>corr=1.0</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM (in nm or in cm-1) of a line given the
observation parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps from the zpd to the longest side
of the interferogram.</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>apod_coeff</strong> – (Optional) Apodization coefficient. 1. stands
for no apodization and gives the FWHM of the central lobe of the
sinc (default 1.)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm_pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm_pix</code><span class="sig-paren">(</span><em>oversampling_ratio=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM of an unapodized sinc line in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Oversampling_ratio:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Ratio of the real number of steps of the
spectrum vs step_nb (must be &gt; 1.) For a two sided interferogram
the oversampling ratio is 2.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_mean_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_mean_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_mean_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean shift at the central wavelength of the band
defined by step and order parameters given its velocity in nm or
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>velocity</strong> – Line velocity in km.s-1</li>
<li><strong>step_nb</strong> – Number of steps</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_radial_velocity">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_radial_velocity</code><span class="sig-paren">(</span><em>line</em>, <em>rest_line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_radial_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radial velocity in km.s-1</p>
<p>V [km.s-1] = c [km.s-1]* (Lambda^2 / Lambda_0^2 - 1) / (Lambda^2 / Lambda_0^2 + 1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>line</strong> – Emission line wavelength/wavenumber (can be a numpy
array)</li>
<li><strong>rest_line</strong> – Rest-frame wavelength/wavenumber (can be a numpy
array but must have the same size as line)</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_resolution">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_resolution</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>corr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the theoretical resolution of a given scan</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps of the longest side of the
interferogram.</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – Correction coefficient for the incident angle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_step_nb">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_step_nb</code><span class="sig-paren">(</span><em>resolution</em>, <em>step</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_step_nb" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of steps on the longest side of the
interferogram given the resolution and the observation
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>resolution</strong> – Resolution</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.corr2theta">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">corr2theta</code><span class="sig-paren">(</span><em>corr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.corr2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the correction coefficient to an incident angle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>corr</strong> – Correction coefficient</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_cm1_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_cm1_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (cannot be 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis_ireg">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis_ireg</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (must be &gt; 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fast_pix2w">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fast_pix2w</code><span class="sig-paren">(</span><em>pix</em>, <em>axis_min</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_pix2w" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of pixel to wavelength/wavenumber</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pix</strong> – position along axis in pixels</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fast_w2pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fast_w2pix</code><span class="sig-paren">(</span><em>w</em>, <em>axis_min</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_w2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of wavelength/wavenumber to pixel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> – wavelength/wavenumber</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_cm12nm</code><span class="sig-paren">(</span><em>fwhm_cm1</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in cm-1 to a FWHM in nm.</p>
<p>The central wavelength in cm-1 of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm_cm1</strong> – FWHM in cm-1</li>
<li><strong>cm1</strong> – Wavelength in cm-1 where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_nm2cm1</code><span class="sig-paren">(</span><em>fwhm_nm</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in nm to a FWHM in cm-1.</p>
<p>The central wavelength in nm of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm_nm</strong> – FWHM in nm</li>
<li><strong>nm</strong> – Wavelength in nm where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Array giving the positions where the gaussian is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM, <img src="_images/mathmpl/math-c0419d808a.png" /></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Array giving the positions where the gaussian is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM, <img src="_images/mathmpl/math-c0419d808a.png" /></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D Gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.guess_snr">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">guess_snr</code><span class="sig-paren">(</span><em>calib_spectrum</em>, <em>flambda</em>, <em>exp_time</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.guess_snr" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess calibrated spectrum snr</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib_spectrum</strong> – Calibrated spectrum</li>
<li><strong>flambda</strong> – Calibration FLAMBDA</li>
<li><strong>exp_time</strong> – Exposure time by step</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.line_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">line_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift given its velocity in nm or in cm-1.</p>
<p>beta = v / c</p>
<p>gamma = sqrt((1 + beta) / (1 - beta))</p>
<p>lambda - lambda_0 = lambda_0  * (gamma - 1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>velocity</strong> – Line velocity in km.s-1</li>
<li><strong>line</strong> – Wavelength/wavenumber of the line. Must be in cm-1 if
wavenumber is True, must be in nm otherwise.</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.lorentzian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">lorentzian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.lorentzian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D lorentzian
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.mertz1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">mertz1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.mertz1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex ILS when Mertz ramp is used during the Fourier transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>ratio</strong> – Ratio of the shortest side over the longest side of
the interferogram</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2cm1</code><span class="sig-paren">(</span><em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a wavenumber in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm</strong> – wavelength in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2pix</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
fast_w2pix is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Axis in nm</li>
<li><strong>nm</strong> – Wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.phase_shift_cm1_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">phase_shift_cm1_axis</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>nm_laser_obs</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.phase_shift_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute phase shift on a given cm1 axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>nm_laser_obs</strong> – Observed calibration laser wavelength (in nm)</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength (in nm)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2cm1</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1_axis</strong> – Axis in cm-1</li>
<li><strong>pix</strong> – Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2nm</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
fast_pix2w is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Axis in nm</li>
<li><strong>pix</strong> – Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc 
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sinc (understood as the Fourier
Transform of a boxcar function from 0 to MPD).</p>
<p>This is the real sinc function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_phased">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_phased</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc function when that can be used to
fit a spectrum with a non perfect correction of the order 0 of the
phase.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>alpha</strong> – Mixing coefficient (in radians).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc21d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc21d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc21d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc2.
THIS IS BOGUS WITH CURRENT DEFINITION OF SINC2 MODEL
:param a: Amplitude
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc convoluted with a gaussian of parameter sigma.</p>
<p>If sigma == 0 returns a pure sinc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – 1D array of float64 giving the positions where the</td>
</tr>
</tbody>
</table>
<p>sinc is evaluated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (dawson definition).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_complex_erf">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_complex_erf</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (erf formulation).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc convoluted with a Gaussian of
parameter sigma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian</li>
<li><strong>no_err</strong> – (Optional) No error is returned (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_phased">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_phased</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc*gauss function when that can be
used to fit a spectrum with a non perfect correction of the order
0 of the phase.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
<li><strong>alpha</strong> – Mixing coefficient (in radians).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.thermal_broadening_kms">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">thermal_broadening_kms</code><span class="sig-paren">(</span><em>wl</em>, <em>aw</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.thermal_broadening_kms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the line due to thermal broadening in km/s.</p>
<p>Equation can be refered to Harwit (Astrophysical concepts) but his
definition gives the HWHM (Half-Width at Half-Maximum).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wl</strong> – Wavelength of the line (in nm)</li>
<li><strong>aw</strong> – Atomic weight of the emitting atom</li>
<li><strong>T</strong> – Temperature in K</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.theta2corr">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">theta2corr</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.theta2corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the incident angle to a correction coefficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>theta</strong> – Incident angle in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.stats">
<span id="orb-utils-stats-module"></span><h2>orb.utils.stats module<a class="headerlink" href="#module-orb.utils.stats" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.stats.robust_mean">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_mean</code><span class="sig-paren">(</span><em>a</em>, <em>weights=None</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>weights</strong> – Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_median">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_median</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_std">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_std</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_sum">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_sum</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.sigmacut">
<code class="descclassname">orb.utils.stats.</code><code class="descname">sigmacut</code><span class="sig-paren">(</span><em>x</em>, <em>sigma=3.0</em>, <em>min_values=3</em>, <em>central_value=None</em>, <em>warn=False</em>, <em>return_index_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – The distribution to cut</li>
<li><strong>sigma</strong> – (Optional) Number of sigma above which values are
considered as deviant (default 3.)</li>
<li><strong>min_values</strong> – (Optional) Minimum number of values to return
(default 3)</li>
<li><strong>central_value</strong> – (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</li>
<li><strong>warn</strong> – (Optional) If False no warning message is printed
(default False).</li>
<li><strong>return_index_list</strong> – (Optional) If True the list of the non
rejected values is returned also (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.validate">
<span id="orb-utils-validate-module"></span><h2>orb.utils.validate module<a class="headerlink" href="#module-orb.utils.validate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.validate.has_dtype">
<code class="descclassname">orb.utils.validate.</code><code class="descname">has_dtype</code><span class="sig-paren">(</span><em>obj</em>, <em>dtype</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray of the correct type
:param obj: object to validate
:param dtype: array dtype
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.has_len">
<code class="descclassname">orb.utils.validate.</code><code class="descname">has_len</code><span class="sig-paren">(</span><em>obj</em>, <em>length</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is 1d and if its length is correct
:param obj: Object to check
:param raise_exception: If True raise an exception else raise a warning.
:param length: length of the object</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.have_same_shape">
<code class="descclassname">orb.utils.validate.</code><code class="descname">have_same_shape</code><span class="sig-paren">(</span><em>objs</em>, <em>raise_exception=True</em>, <em>object_name='arrays'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.have_same_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all numpy.ndarrays have the same shape
:param obj: list of objects to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.index">
<code class="descclassname">orb.utils.validate.</code><code class="descname">index</code><span class="sig-paren">(</span><em>a</em>, <em>a_min</em>, <em>a_max</em>, <em>clip=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a valid index (clipped between a_min and a_max - 1) or raise
an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – index. Can be a list or an array of indexes.</li>
<li><strong>a_min</strong> – Min index.</li>
<li><strong>a_max</strong> – Max index (max possible index will be considered as
a_max -1)</li>
<li><strong>clip</strong> – (Optional) If True return an index inside the
boundaries, else: raise an exception (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_1darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_1darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_1darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 1d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_2darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_2darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_2darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 2d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_3darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_3darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_3darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 3d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_iterable">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_iterable</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>check if object is a tuple or a list or a 1darray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> – Object to check</li>
<li><strong>raise_exception</strong> – If True raise an exception else raise a warning.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_ndarray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_ndarray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_xdarray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_xdarray</code><span class="sig-paren">(</span><em>obj</em>, <em>ndim</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_xdarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray with the correct number of
dimensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> – object to validate</li>
<li><strong>ndim</strong> – number of dimensions</li>
<li><strong>raise_exception</strong> – If True raise an exception else raise a warning.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.vector">
<span id="orb-utils-vector-module"></span><h2>orb.utils.vector module<a class="headerlink" href="#module-orb.utils.vector" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.vector.complex2float">
<code class="descclassname">orb.utils.vector.</code><code class="descname">complex2float</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.complex2float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.vector.correct_vector">
<code class="descclassname">orb.utils.vector.</code><code class="descname">correct_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>bad_value=nan</em>, <em>deg=3</em>, <em>polyfit=False</em>, <em>smoothing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vector</strong> – The vector to be corrected.</li>
<li><strong>bad_value</strong> – (Optional) Bad value to correct (default np.nan)</li>
<li><strong>deg</strong> – (Optional) Spline degree or polyfit degree (default 3)</li>
<li><strong>polyfit</strong> – (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.fft_filter">
<code class="descclassname">orb.utils.vector.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>a</em>, <em>cutoff_coeff</em>, <em>width_coeff=0.2</em>, <em>filter_type='high_pass'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Vector to filter</li>
<li><strong>cutoff_coeff</strong> – Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</li>
<li><strong>width_coeff</strong> – (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</li>
<li><strong>filter_type</strong> – (Optional) Type of filter to use. Can be
‘high_pass’ or ‘low_pass’.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.float2complex">
<code class="descclassname">orb.utils.vector.</code><code class="descname">float2complex</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.float2complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_axis">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_axis</code><span class="sig-paren">(</span><em>a</em>, <em>new_axis</em>, <em>deg</em>, <em>old_axis=None</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – vector to interpolate</li>
<li><strong>new_axis</strong> – Interpolation axis</li>
<li><strong>deg</strong> – Interpolation degree</li>
<li><strong>old_axis</strong> – (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</li>
<li><strong>fill_value</strong> – (Optional) extrapolated points are filled with
this value (default np.nan)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_size">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_size</code><span class="sig-paren">(</span><em>a</em>, <em>size</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – vector to interpolate</li>
<li><strong>size</strong> – New size of the vector</li>
<li><strong>deg</strong> – Interpolation degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.polyfit1d">
<code class="descclassname">orb.utils.vector.</code><code class="descname">polyfit1d</code><span class="sig-paren">(</span><em>a</em>, <em>deg</em>, <em>w=None</em>, <em>return_coeffs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Vector to fit</li>
<li><strong>deg</strong> – Fit degree</li>
<li><strong>return_coeffs</strong> – (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</li>
<li><strong>w</strong> – (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.robust_unwrap">
<code class="descclassname">orb.utils.vector.</code><code class="descname">robust_unwrap</code><span class="sig-paren">(</span><em>vec</em>, <em>dis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.robust_unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap a vector with a given discontinuity. Robust to nans.</p>
<p>Note that the returned vector will start somewhere around 0 since
all modulo bias is removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec</strong> – 1d Vector to unwrap.</li>
<li><strong>dis</strong> – discontinuity (eg. np.pi)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.smooth">
<code class="descclassname">orb.utils.vector.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>a</em>, <em>deg=2</em>, <em>kind='gaussian'</em>, <em>keep_sides=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – Vector to smooth</li>
<li><strong>deg</strong> – (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</li>
<li><strong>kind</strong> – Kind of smoothing function. ‘median’ or ‘mean’ are
self-explanatory. ‘gaussian’ uses a gaussian function for a
weighted average. ‘gaussian_conv’ and ‘cos_conv’ make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default ‘gaussian’).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params keep_sides:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last">If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.web">
<span id="orb-utils-web-module"></span><h2>orb.utils.web module<a class="headerlink" href="#module-orb.utils.web" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.web.query_sesame">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_sesame</code><span class="sig-paren">(</span><em>object_name</em>, <em>verbose=True</em>, <em>degree=False</em>, <em>pm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_sesame" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the SESAME Database to get RA/DEC given the name of an
object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>object_name</strong> – Name of the object</li>
<li><strong>verbose</strong> – (Optional) If True print messages (default True)</li>
<li><strong>degree</strong> – (Optional) If True return RA DEC in degrees
(default False)</li>
<li><strong>pm</strong> – (Optional) If True proper motion is also returned
(default False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[RA, DEC]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.web.query_vizier">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_vizier</code><span class="sig-paren">(</span><em>radius</em>, <em>target_ra</em>, <em>target_dec</em>, <em>catalog='gaia'</em>, <em>max_stars=100</em>, <em>return_all_columns=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<p>Note that the idea of this method has been picked from an IDL
function: QUERYVIZIER
(<a class="reference external" href="http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro">http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radius</strong> – Radius around the target in arc-minutes.</li>
<li><strong>target_ra</strong> – Target RA in degrees</li>
<li><strong>target_dec</strong> – Target DEC in degrees</li>
<li><strong>max_stars</strong> – (Optional) Maximum number of rows to retrieve
(default 100)</li>
<li><strong>catalog</strong> – (Optional) can be ‘usno’ - Version B1 of the US
Naval Observatory catalog (2003), ‘gaia’ - GAIA DR1, or ‘2mass’
- 2MASS (default Gaia)</li>
<li><strong>return_all_columns</strong> – (Optional) If True, return all
columns. Else only ra, dec and Mag are returned (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="changelog.html" class="btn btn-neutral float-right" title="Changelog" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="orb.ext.html" class="btn btn-neutral float-left" title="orb.ext package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Thomas Martin (thomas.martin.1@ulaval.ca)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>